<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Miss Han - A Gift from Mr Meng</title>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@600&display=swap" rel="stylesheet">
    <style>
        /* åŸæœ‰æ ·å¼ä¸å˜ï¼Œç§»é™¤å¼•å¯¼å±‚æ ·å¼ */
        body { margin: 0; overflow: hidden; background: radial-gradient(circle at center, #0a0a14 0%, #000 100%); font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        .header {
            position: absolute;
            top: 40px;
            width: 100%;
            text-align: center;
            z-index: 100;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 {
            font-family: 'Dancing Script', cursive;
            font-size: 4.5rem;
            margin: 0;
            background: linear-gradient(to bottom, #fffef0 0%, #ffd700 40%, #ff8c00 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 8px rgba(0,0,0,0.8));
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            letter-spacing: 1px;
        }
        .signature {
            font-family: 'Dancing Script', cursive;
            font-size: 1.6rem;
            color: #ffd700;
            margin-top: 5px;
            transform: translateX(180px);
            opacity: 0.9;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.8);
        }
        video { 
            transform: scaleX(-1); 
            position: absolute; 
            bottom: 20px; 
            right: 20px; 
            width: 180px; 
            height: 135px;
            border: 1.5px solid rgba(255, 215, 0, 0.4);
            border-radius: 12px; 
            object-fit: cover;
            opacity: 0.5;
        }
        .status-dot {
            position: absolute;
            bottom: 165px;
            right: 30px;
            color: rgba(255,255,255,0.6);
            font-size: 0.7rem;
            letter-spacing: 1px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Miss Han, Merry Christmas!</h1>
        <div class="signature">from Mr Meng</div>
    </div>
    <div id="status" class="status-dot">MAGIC LOADING...</div>
    <div id="canvas-container"></div>
    <video id="video" autoplay playsinline></video>
    
    <!-- éŸ³é¢‘å…ƒç´ ï¼šå¢åŠ é¢„åŠ è½½å’Œé™éŸ³åˆå§‹åŒ–ï¼ˆå…³é”®ï¼‰ -->
    <audio id="backgroundMusic" loop preload="auto" muted>
        <source src="music.mp3" type="audio/mpeg">
        <source src="music.wav" type="audio/wav">
        æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘æ’­æ”¾
    </audio>

    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        // ========== æ ¸å¿ƒï¼šæ— æ„Ÿè§¦å‘éŸ³é¢‘æ’­æ”¾ ==========
        const backgroundMusic = document.getElementById('backgroundMusic');
        let audioInited = false; // æ ‡è®°éŸ³é¢‘æ˜¯å¦å·²åˆå§‹åŒ–

        // 1. ç›‘å¬ä»»æ„è§¦æ‘¸äº‹ä»¶ï¼ˆæ»‘åŠ¨/è½»è§¦/é•¿æŒ‰éƒ½ç®—ï¼Œæ— éœ€ç‚¹å‡»ï¼‰
        function initAudioByTouch() {
            if (audioInited) return;
            // å…ˆå–æ¶ˆé™éŸ³ï¼Œå†æ’­æ”¾ï¼ˆç§»åŠ¨ç«¯å¿…é¡»æ­¥éª¤ï¼‰
            backgroundMusic.muted = false;
            backgroundMusic.play().then(() => {
                audioInited = true;
                console.log("éŸ³é¢‘é€šè¿‡è§¦æ‘¸è§¦å‘æ’­æ”¾");
            }).catch(e => {
                console.log("è§¦æ‘¸è§¦å‘å¤±è´¥ï¼Œå°è¯•å…¶ä»–æ–¹å¼ï¼š", e);
                initAudioByMotion(); // å…œåº•ï¼šé™€èºä»ªè§¦å‘
            });
            // åªç›‘å¬ä¸€æ¬¡ï¼Œé¿å…é‡å¤è§¦å‘
            document.removeEventListener('touchstart', initAudioByTouch);
        }

        // 2. å…œåº•ï¼šé™€èºä»ª/è®¾å¤‡è¿åŠ¨è§¦å‘ï¼ˆéƒ¨åˆ†æ‰‹æœºæ”¯æŒï¼‰
        function initAudioByMotion() {
            if (audioInited || !window.DeviceMotionEvent) return;
            // è¯·æ±‚è®¾å¤‡è¿åŠ¨æƒé™ï¼ˆéƒ¨åˆ†å®‰å“éœ€è¦ï¼‰
            if (DeviceMotionEvent.requestPermission) {
                DeviceMotionEvent.requestPermission().then(permissionState => {
                    if (permissionState === 'granted') {
                        window.addEventListener('devicemotion', function motionHandler() {
                            if (!audioInited) {
                                backgroundMusic.muted = false;
                                backgroundMusic.play().then(() => {
                                    audioInited = true;
                                    console.log("éŸ³é¢‘é€šè¿‡é™€èºä»ªè§¦å‘æ’­æ”¾");
                                });
                            }
                            window.removeEventListener('devicemotion', motionHandler);
                        }, { once: true });
                    }
                });
            }
        }

        // 3. å¾®ä¿¡æµè§ˆå™¨ä¸“å±ï¼šJSBridge è§¦å‘ï¼ˆæ— éœ€ç”¨æˆ·äº¤äº’ï¼‰
        function initAudioForWechat() {
            if (audioInited) return;
            if (typeof WeixinJSBridge !== 'undefined') {
                WeixinJSBridge.invoke('getNetworkType', {}, () => {
                    backgroundMusic.muted = false;
                    backgroundMusic.play().then(() => audioInited = true);
                });
            } else {
                document.addEventListener("WeixinJSBridgeReady", () => {
                    backgroundMusic.muted = false;
                    backgroundMusic.play().then(() => audioInited = true);
                }, false);
            }
        }

        // æ³¨å†Œç›‘å¬ï¼šä¼˜å…ˆè§¦æ‘¸ï¼Œå…¼å®¹å¾®ä¿¡ï¼Œå…œåº•é™€èºä»ª
        document.addEventListener('touchstart', initAudioByTouch, { passive: true });
        initAudioForWechat(); // å¾®ä¿¡ç¯å¢ƒè‡ªåŠ¨è§¦å‘
        setTimeout(initAudioByMotion, 1000); // 1ç§’åå°è¯•é™€èºä»ªå…œåº•

        // ========== åŸæœ‰ 3D åœºæ™¯ä»£ç ï¼ˆå®Œå…¨ä¸å˜ï¼‰ ==========
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 3, 28); 
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const particleCount = 20000; 
        const geometry = new THREE.BufferGeometry();
        const posArray = new Float32Array(particleCount * 3);
        const treePositions = new Float32Array(particleCount * 3);
        const starPositions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);

        const endTreeBody = Math.floor(particleCount * 0.60);
        const endTrunk = Math.floor(particleCount * 0.70);
        const endTopBall = Math.floor(particleCount * 0.73);
        const endRibbon = Math.floor(particleCount * 0.88);

        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            starPositions[i3] = (Math.random() - 0.5) * 75;
            starPositions[i3+1] = (Math.random() - 0.5) * 65;
            starPositions[i3+2] = (Math.random() - 0.5) * 55;

            let r, g, b, x, y, z;

            if (i < endTreeBody) {
                const ratio = i / endTreeBody;
                const h = 16 * ratio;
                const rad = (16 - h) * 0.4;
                const ang = 0.6 * i;
                x = Math.cos(ang) * rad + (Math.random()-0.5)*0.5;
                y = h - 9.5;
                z = Math.sin(ang) * rad + (Math.random()-0.5)*0.5;
                const cr = Math.random();
                if (cr < 0.4) { r=1; g=0.85; b=0.2; } 
                else if (cr < 0.7) { r=0.1; g=0.7; b=0.3; } 
                else { r=1; g=0.3; b=0.7; }
            } else if (i < endTrunk) {
                x = Math.cos(Math.random()*7) * 0.8 * Math.random();
                y = ((i - endTreeBody) / (endTrunk - endTreeBody) * 4.5) - 14;
                z = Math.sin(Math.random()*7) * 0.8 * Math.random();
                r=0.4; g=0.2; b=0.05;
            } else if (i < endTopBall) {
                const ratio = (i - endTrunk) / (endTopBall - endTrunk);
                const phi = Math.acos(-1 + (2 * ratio));
                const theta = Math.sqrt(particleCount * Math.PI) * phi;
                const brad = 1.3;
                x = brad * Math.cos(theta) * Math.sin(phi);
                y = brad * Math.sin(theta) * Math.sin(phi) + 7.5; 
                z = brad * Math.cos(phi);
                r=1.0; g=1.0; b=0.7; 
            } else if (i < endRibbon) {
                const ratio = (i - endTopBall) / (endRibbon - endTopBall);
                const h = 16 * (1 - ratio);
                const rad = (16 - h) * 0.43 + 0.6; 
                const ang = h * 2.2; 
                x = Math.cos(ang) * rad;
                y = h - 9.5;
                z = Math.sin(ang) * rad;
                r=1.0; g=0.9; b=0.3; 
            } else {
                const ratio = (i - endRibbon) / (particleCount - endRibbon);
                const h = 15.5 * (1 - ratio);
                const rad = (16 - h) * 0.46 + 0.9;
                const ang = h * 2.2 + (Math.random()-0.5)*0.6;
                x = Math.cos(ang) * rad;
                y = h - 9.5 + (Math.random()-0.5)*0.6;
                z = Math.sin(ang) * rad;
                const cr = Math.random();
                if(cr<0.35){r=1;g=0.2;b=0.2;} 
                else if(cr<0.7){r=0.2;g=0.5;b=1;} 
                else {r=0.9;g=0.2;b=0.9;}
            }

            treePositions[i3] = x; treePositions[i3+1] = y; treePositions[i3+2] = z;
            colors[i3] = r; colors[i3+1] = g; colors[i3+2] = b;
            posArray[i3] = starPositions[i3]; posArray[i3+1] = starPositions[i3+1]; posArray[i3+2] = starPositions[i3+2];
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: 0.13,
            vertexColors: true,
            transparent: true,
            opacity: 0.95,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            sizeAttenuation: true
        });

        const treeParticles = new THREE.Points(geometry, material);
        scene.add(treeParticles);

        // ========== äº¤äº’é€»è¾‘ï¼ˆä¿®æ”¹æ‰‹åŠ¿è¯†åˆ«è§¦å‘éŸ³ä¹ï¼‰ ==========
        let isFist = false; 
        let rotationSpeed = 0.002;

        function updatePhysics() {
            const posAttr = geometry.attributes.position;
            const lerpSpeed = isFist ? 0.06 : 0.025; 

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const tx = isFist ? treePositions[i3] : starPositions[i3];
                const ty = isFist ? treePositions[i3+1] : starPositions[i3+1];
                const tz = isFist ? treePositions[i3+2] : starPositions[i3+2];

                posAttr.array[i3] += (tx - posAttr.array[i3]) * lerpSpeed;
                posAttr.array[i3+1] += (ty - posAttr.array[i3+1]) * lerpSpeed;
                posAttr.array[i3+2] += (tz - posAttr.array[i3+2]) * lerpSpeed;
            }
            posAttr.needsUpdate = true;

            const targetRot = isFist ? 0.012 : 0.0015;
            rotationSpeed += (targetRot - rotationSpeed) * 0.05;
            treeParticles.rotation.y += rotationSpeed;
        }

        // ========== æ‰‹åŠ¿è¯†åˆ«ï¼ˆé¦–æ¬¡è¯†åˆ«æ—¶ç¡®ä¿éŸ³ä¹æ’­æ”¾ï¼‰ ==========
        const videoElement = document.getElementById('video');
        const statusText = document.getElementById('status');

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                // é¦–æ¬¡æ‰‹åŠ¿è¯†åˆ«æ—¶ï¼Œå¼ºåˆ¶è§¦å‘éŸ³é¢‘ï¼ˆå…œåº•ï¼‰
                if (!audioInited) {
                    backgroundMusic.muted = false;
                    backgroundMusic.play().catch(e => {
                        console.log("æ‰‹åŠ¿è§¦å‘éŸ³é¢‘å¤±è´¥ï¼Œéœ€è½»è§¦å±å¹•ï¼š", e);
                        statusText.innerText = "è½»è§¦å±å¹•å¼€å¯éŸ³ä¹ âœ¨";
                    });
                    audioInited = true; // æ ‡è®°ï¼Œé¿å…é‡å¤æç¤º
                }

                const hand = results.multiHandLandmarks[0];
                const palmCenter = hand[9];
                const fingerTips = [8, 12, 16, 20];
                let totalDist = 0;
                fingerTips.forEach(idx => {
                    const tip = hand[idx];
                    totalDist += Math.sqrt(Math.pow(tip.x - palmCenter.x, 2) + Math.pow(tip.y - palmCenter.y, 2));
                });
                isFist = (totalDist / 4) < 0.13;
                statusText.innerText = isFist ? "MERRY CHRISTMAS âœŠ" : "RELEASE THE MAGIC ğŸ–ï¸";
                
                camera.position.x += ((hand[9].x - 0.5) * 12 - camera.position.x) * 0.05;
                camera.position.y += (-(hand[9].y - 0.5) * 8 + 3 - camera.position.y) * 0.05;
                camera.lookAt(0, 0, 0); 
            } else {
                isFist = false;
                statusText.innerText = audioInited ? "WAITING FOR HAND..." : "è½»è§¦å±å¹•å¼€å¯é­”æ³• âœ¨";
            }
        }

        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
        hands.onResults(onResults);

        const cameraMP = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cameraMP.start();

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
